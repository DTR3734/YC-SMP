import { scryptSync, randomBytes, timingSafeEqual } from 'crypto';

const SALT_LENGTH = 16;
const KEY_LENGTH = 64;
// scrypt parameters are chosen to be reasonably secure.
const SCRYPT_OPTIONS = { N: 16384, r: 8, p: 1 };

/**
 * Hashes a password with a random salt using scrypt.
 * @param password The plaintext password to hash.
 * @returns An object containing the salt and the derived key (hash), both hex-encoded.
 */
export const hashPassword = (password: string): { salt: string, hash: string } => {
    const salt = randomBytes(SALT_LENGTH).toString('hex');
    const hash = scryptSync(password, salt, KEY_LENGTH, SCRYPT_OPTIONS).toString('hex');
    return { salt, hash };
};

/**
 * Verifies a plaintext password against a stored salt and hash.
 * Uses timingSafeEqual to prevent timing attacks.
 * @param password The plaintext password to verify.
 * @param salt The salt used to hash the original password.
 * @param hash The stored password hash.
 * @returns True if the password is correct, false otherwise.
 */
export const verifyPassword = (password: string, salt: string, hash: string): boolean => {
    const hashToCompare = scryptSync(password, salt, KEY_LENGTH, SCRYPT_OPTIONS);
    const storedHash = Buffer.from(hash, 'hex');

    // It's crucial that the buffers have the same length for timingSafeEqual to work.
    if (hashToCompare.length !== storedHash.length) {
        // This is a defensive check; they should always be the same length
        // if generated by the same parameters.
        return false;
    }
    
    return timingSafeEqual(hashToCompare, storedHash);
};
